#pragma once

typedef const unsigned char* LPCBYTE;

const char c_szZ32[] = "ABCDEFGHIJKLMNOPQRSTUV0123456789";
const BYTE c_arInv[] = {
	0xFF, 0xFF,	0xFF, 0xFF,	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF,	0xFF, 0xFF,	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF,	0xFF, 0xFF,	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

	0xFF, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E,
	0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF,	0xFF, 0xFF,	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

	0xFF, 0xFF,	0xFF, 0xFF,	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF,	0xFF, 0xFF,	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF,	0xFF, 0xFF,	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF,	0xFF, 0xFF,	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

	0xFF, 0xFF,	0xFF, 0xFF,	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF,	0xFF, 0xFF,	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF,	0xFF, 0xFF,	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF,	0xFF, 0xFF,	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};


class CConversion
{
public:

	CConversion(void)
	{
	}

	~CConversion(void)
	{
	}

// Operations
	static void ByteArray2String(LPBYTE pArr, UINT nLen, LPSTR pszDest)
	{
		UINT buf;
		LPCBYTE pEnd = pArr + nLen;
		LPCBYTE p;
		UINT i, j;
		UINT nBlocks = nLen / 5;

		for (p = pArr, i = 0; i < nBlocks; i++, p += 5)
		{
			buf = *((LPUINT) p);
			for (j = 0; j < 6; j++, buf >>= 5)
			{
				*(pszDest++) = c_szZ32[ (buf & 0x0000001F) ];
			}

			buf = *((LPUINT) (p + 1)) >> 0x16;
			*(pszDest++) = c_szZ32[ (buf & 0x0000001F) ];
			*(pszDest++) = c_szZ32[ ((buf >> 5) & 0x0000001F) ];
		}

		//Last block
		if (pEnd > p)
		{
			//Mask the block along its length
			//NB: pEnd - p = length of source remainder in bytes
			buf = *((LPUINT) p) & ((0x100 << ((pEnd - p - 1) << 3)) - 1);

			//Here nBlocks is number of characters to be generated 
			//for the remainder
			nBlocks = RequiredStringLength(pEnd - p);
			for (i = 0; i < nBlocks; i++, buf >>= 5)
			{
				*(pszDest++) = c_szZ32[ (buf & 0x0000001F) ];
			}
		}

		*pszDest = '\x00';
	}

	static void String2ByteArray(LPCSTR pszArr, LPBYTE pDest) throw(...)
	{
		int nBits = 0;
		UINT rx = 0; //pseudo-register
		BYTE b;

		while (*pszArr != 0)
		{
			//push bits into register
			while (nBits < 8)
			{
				b = c_arInv[ (unsigned) *(pszArr++) ];
				if (0xFF == b)
				{
					throw CBadEncodingException(CBadEncodingException::cofBadChar);
				}
				
				rx |= b << nBits;
				nBits += 5;
			}

			//pop into destination
			*(pDest++) = (BYTE) rx;
			nBits -= 8;
			rx >>= 8;
		}
	}

	static UINT RequiredStringLength(UINT nBinaryLen)
	{
		return (nBinaryLen << 3) / 5 + UINT(0 != (nBinaryLen %5));
	}

	static UINT RequiredBinaryLength(LPCTSTR psz) throw(...)
	{
		UINT nLen = lstrlen(psz);
		UINT nLBLen = nLen & 0x0007; //length of last block
		if ((1 == nLBLen) || (3 == nLBLen) || (6 == nLBLen))
		{
			throw CBadEncodingException(CBadEncodingException::cofBadLength);
		}
		return (nLen * 5) >> 3;
	}
};
